
---

```markdown
# ğŸ“œ Longest Substring with At Least K Repeating Characters

## ğŸ§™â€â™‚ï¸ Problem Story

Once upon a string...

Imagine you have a long ribbon of lowercase letters. You're searching for the most powerful spell hidden withinâ€”a substring where **every character appears at least `k` times**. If any letter in your chosen piece is too weak (appears less than `k` times), the spell breaks.

Your goal: find the **longest valid substring** where each letter shows up at least `k` times. If no such substring exists, return `0`.

Think of it like picking ingredients for a cakeâ€”you need at least `k` scoops of every required item. If anything falls short, itâ€™s not a proper cakeâ€¦ or spell!

---

## ğŸ§  Problem Statement

Given a string `s` and an integer `k`, return the length of the **longest substring** where **every character appears â‰¥ k times**.

### Example 1:
```text
Input: s = "aaabb", k = 3
Output: 3
Explanation: The longest valid substring is "aaa"
```

### Example 2:
```text
Input: s = "ababbc", k = 2
Output: 5
Explanation: "ababb" is the longest valid substring
```

---

## ğŸš€ Approach

We use a **multi-pass sliding window**. For every possible target number of unique characters (1 to 26), we:

1. Slide a window through the string.
2. Track character frequencies.
3. Check whether every character in the window appears â‰¥ `k` times.

If so, we update our longest valid substring length.

### Time Complexity:
- $$O(26 \cdot n)$$ where `n` is the length of the string

### Space Complexity:
- $$O(1)$$ â€” constant space for tracking 26 letters

---

## ğŸ§¾ Java Code

```java
class Solution {
    public int longestSubstring(String s, int k) {
        int maxLen = 0;

        for (int targetUnique = 1; targetUnique <= 26; targetUnique++) {
            int[] count = new int[26];
            int start = 0, end = 0, unique = 0, countAtLeastK = 0;

            while (end < s.length()) {
                if (unique <= targetUnique) {
                    int idx = s.charAt(end) - 'a';
                    if (count[idx] == 0) unique++;
                    count[idx]++;
                    if (count[idx] == k) countAtLeastK++;
                    end++;
                } else {
                    int idx = s.charAt(start) - 'a';
                    if (count[idx] == k) countAtLeastK--;
                    count[idx]--;
                    if (count[idx] == 0) unique--;
                    start++;
                }

                if (unique == targetUnique && unique == countAtLeastK) {
                    maxLen = Math.max(maxLen, end - start);
                }
            }
        }

        return maxLen;
    }
}
```

---

## ğŸ§ª Dry Run Example

Letâ€™s dry run with `s = "ababbc"` and `k = 2`. We'll fix `targetUnique = 2`.

### Initial State:
```
start = 0, end = 0
unique = 0, countAtLeastK = 0
count = [0 x 26]
maxLen = 0
```

### Step-by-step:

1. Add 'a' â†’ unique = 1, countAtLeastK = 0
2. Add 'b' â†’ unique = 2
3. Add 'a' again â†’ 'a' reaches k â‡’ countAtLeastK = 1
4. Add 'b' again â†’ 'b' reaches k â‡’ countAtLeastK = 2  
   âœ… Valid window: "abab" â†’ maxLen = 4
5. Add another 'b' â†’ still valid â†’ "ababb" â†’ maxLen = 5
6. Add 'c' â†’ unique becomes 3  
   âŒ Exceeds target, start shrinking...

Eventually, longest valid substring = `"ababb"` â†’ **length = 5**

---

## âœ¨ Conclusion

This sliding window method balances frequency counting and uniqueness constraints smartly. Itâ€™s efficient, intuitive, and easy to teachâ€”especially with dry runs!

Feel free to â­ the repo if this helped, or fork it for experimentation!

```

Want me to make an image version of this walkthrough or sketch out a visual tracker for the variables during the dry run? Iâ€™d love to help!
