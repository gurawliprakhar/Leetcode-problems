### `2210.Count_Hills_and_Valleys_in_an_Array.md`
---

## ðŸ”ï¸ LeetCode 2210 - Count Hills and Valleys in an Array

### ðŸ”¸ Difficulty: Easy  
### ðŸ”¹ Tags: Array, Pattern Recognition

---

## ðŸ“– Problem Statement (Hinglish Explanation)

Apne ko ek array `nums[]` diya gaya hai. Har index check karna hai:

- Agar uske **left aur right dono side ke closest non-equal neighbors chhote hain**, toh wo index **hill** hai.
- Agar dono side ke **neighbors bade hain**, toh wo index **valley** hai.

ðŸ”¸ **Important rule**:  
Agar consecutive equal elements ho (jaise `[1,1,1]`), toh wo **same hill ya valley ka part maane jaayenge** â€” **double count nahi karna**.

---

## ðŸ” Example:

### Input:
```text
nums = [2, 4, 1, 1, 6, 5]
```

### Cleaned Array (after removing duplicates):
```text
[2, 4, 1, 6, 5]
```

### Explanation:
- `4` â†’ Hill (`4 > 2 && 4 > 1`)
- `1` â†’ Valley (`1 < 4 && 1 < 6`)
- `6` â†’ Hill (`6 > 1 && 6 > 5`)  
âœ… Final Count â†’ **3 hills/valleys**

---

## ðŸ’» Java Code

```java
class Solution {
    public int countHillValley(int[] nums) {
        // Step 1: Remove consecutive duplicates
        int k = 1;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] != nums[i - 1]) {
                nums[k++] = nums[i];
            }
        }

        // Step 2: Count hills and valleys
        int ans = 0;
        for (int i = 1; i < k - 1; i++) {
            if ((nums[i - 1] < nums[i]) == (nums[i] > nums[i + 1])) {
                ans++;
            }
        }

        return ans;
    }
}
```

---

## ðŸ§® Dry Run with Sample Input

### Input:
```text
[2, 4, 1, 1, 6, 5]
```

### Step 1: Remove consecutive duplicates  
```text
Cleaned Array: [2, 4, 1, 6, 5]
k = 5
```

### Step 2: Check from index `1` to `k-2 = 3`

- `i = 1`: `4 > 2 && 4 > 1` â†’ âœ… Hill â†’ `ans = 1`
- `i = 2`: `1 < 4 && 1 < 6` â†’ âœ… Valley â†’ `ans = 2`
- `i = 3`: `6 > 1 && 6 > 5` â†’ âœ… Hill â†’ `ans = 3`

---

## âœ… Output:
```text
3 hills/valleys
```

---

